#!/usr/bin/env bash
#
# Move a path to the shell-friendly equivalent.
#

usage() {
    cat <<EOF
Usage: ${0#m#*/} [options]
Move a path to the shell-friendly equivalent

  Options:
    -s          don't be recursive (i.e. only change file, not its directory)
    -n          dry run - perform a trial run with no changes made
    -v          be verbose (use mv -v option)
    -h          display this help message
EOF
}

while getopts "snvh" opt; do
    case $opt in
        s) # -don't- be recursive 
            is_single=1
            ;;
        n) # dry run, make no changes
            is_dryrun=1
            ;;
        v) # be verbose
            yn_verbose="-v"
            ;;
        h) # display help
            usage
            exit 0
    esac
done

# shift positional parameters, having found options
shift $(( OPTIND-1 ))

if [ ! -e "$1" ]; then
    echo "error: file does not exist"
    exit 1
fi

# prepend working directory if we're renaming the whole path
# move to the file's starting location
orig_path=$(readlink -f "$1")

# if we get a file, remove extension to append later
orig_file=$(basename "$1")
if [ $is_single ]; then
    working_path="$orig_file"
else
    working_path="$orig_path"
fi

if [ -f "$orig_path" ]; then
    working_path=${working_path%.*}
    ext=".${orig_file##*.}"
    # TODO: if file has no extension, $ext is the file name :<
fi



edited_path=$(echo "$working_path" | \
               sed -e "s/ - /-/g"         \
                   -e "s/ /-/g"           \
                   -e "s/\(.*\)/\L\1/g"   \
                   -e "s/[\.;':,()!?]//g" \
                   -e "s/--/-/g"          \
                   -e "s/&/and/g")
#               1. replace " - " with "-" (so no "---" in paths)
#               2. replace spaces with hyphen
#               3. to lower
#               4. remove almost all punctuation
#               5. replace "--" with "-" (can I make superfluous if I redorer?)
#               6. replace & with "and"

edited_ext=$(echo "$ext" | \
               sed -e "s/\(.*\)/\L\1/g")
#               1. to lower

# prepend original path if we didn't change it
if [ $is_single ]; then
    edited_path="$(dirname $orig_path)/$edited_path"
    echo
    echo "Edited path (single): $edited_path"
fi
# append extension (for non-files, empty string)
new_path="${edited_path}${edited_ext}"

if [[ "$orig_path" == "$new_path" ]]; then
    echo "that path is already shell-friendly!"
    exit 0
else
    if [[ $is_dryrun ]]; then
        # TODO: can I make this any neater? all I do is prepend echo, but I
        #       feel that would be dangerous/not 'right'.
        echo "mkdir -p \"$(dirname "$new_path")\""
        echo "mv $yn_verbose \""$orig_path"\" \""$new_path"\""
    else
        mkdir -p "$(dirname "$new_path")"
        # should I use $1, or readlink-ized $orig_path?
        mv $yn_verbose "$1" "$new_path"
    fi
fi
